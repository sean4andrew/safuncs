---
title: "Testing Grounds"
output: 
  rmdformats::readthedown:
    code_download: true
date: '`r format(Sys.time(), "%d %B, %Y")`'
---

# Heading 1

```{r}
remotes::install_github("sean4andrew/safuncs")
upercent_signif_seackage() 
```


```{r}
##################################################### Function 10 - Surv_Power() ####################################################

#' Calculate Power for Survival Studies
#'
#' @description Calculates the power of global and/or pairwise hypothesis tests for survival studies with support over a range of experimental designs. This versatility is enabled by the simulation-based approach of the power calculation, using the modular \code{Surv_Simul()} to simulate survival data from various experimental designs. Power calculations can be made to account for inter-tank variation using a mixed cox proportional hazards model (set the argument \code{model} to "coxph_glmm"). Additionally, power calculations can account for the multiplicity of pairwise comparisons using the \code{pairwise_corr} argument. Users can compare power across different experimental designs by specifying each as a list element in \code{Surv_Simul()}. The results are returned as dataframes and plots.
#'
#' @details Power calculation follows the standard procedure for simulation approaches. First, the user simulates hypothetical future sample sets using \code{Surv_Simul()}. For each sample set, a p-value is calculated by \code{Surv_Power()}. The percentage of p-values below 0.05 (positives) were then calculated, representing power. The percent positives can also represent false positive rate if the population/truth from which different treatments are simulated are identical.
#'
#' @param simul_db A dataframe containing the simulated survival sample sets generated from \code{Surv_Simul()}.
#' @param global_test A character vector representing the method(s) used for global hypothesis testing of significance of Trt.ID. Methods available are: 'logrank', 'wald', 'score', 'LRT'. 'logrank' represents the global logrank test of significance. The latter three methods are standard global hypothesis testing methods for model fits. They are only available when the argument \code{model} is specified (i.e. not NULL).'wald' represents the Wald Chisquare Test (also known as joint test) which assesses whether model parameters (log(hazard ratio)) are significantly different than 0 (i.e. HRs â‰  1). Wald test can be done for various cox-proportional hazards model that could be relevant to our studies (glm, glmm, and gee). Due to its broad applicability, while also producing practically the same p-value (most of the time) compared to the other two test for models, 'wald' is recommended of the three. 'score' represents the Lagrange multiplier or Score test. 'LRT' represents the likelihood ratio test. Defaults to 'logrank' for now due to its ubiquity of use.
#' @param model A character vector representing the model(s) to fit for hypothesis testing. Models available are: 'coxph_glm' and 'coxph_glmm'. 'coxph_glm' represents the standard cox proportional hazard model fitted using \code{survival::coxph()} with Trt.ID as a fixed factor. 'coxph_glmm' represents the mixed cox proportional hazard model fitted using \code{coxme::coxme()} with Trt.ID as a fixed factor and Tank.ID as a random factor to account for inter-tank variation. Defaults to NULL where no model is used for hypothesis tests.
#' @param pairwise_test A character vector representing the method(s) used for pairwise comparisons. Use "logrank" to calculate power for logrank tests comparing different treatments. Use "EMM" to calculate power using Estimated Marginal Means based on model estimates (from 'coxph_glm' and/or 'coxph_glmm'). Defaults to "logrank".
#' @param pairwise_corr A character vector representing the method(s) used to adjust p-values for multiplicity of pairwise comparisons. The adjustment method affects power of the pairwise comparisons. Methods available are: "tukey", "holm", "hochberg", "hommel", "bonferroni", "BH", "BY", and "none". In \bold{Details}, I discuss categories of the adjustment methods and provided a recommendation for "BH". Defaults to "none" for now.
#' @param data_out Whether to output dataframe(s) containing the power values calculated for the global and/or pairwise hypothesis tests. Defaults to TRUE.
#' @param plot_out Whether to display plot(s) illustrating power from global and/or pairwise hypothesis tests. Defaults to TRUE
#' @param plot_lines Whether to plot lines connecting points of the same "group" in the plot output. Defaults to TRUE.
#' @param xlab A string representing the x-axis title. Defaults to "List Element #".
#' @param xnames Vector of names for x-axis labels. Defaults to NULL where names are the list element numbers from \code{Surv_Gen()}.
#' @param plot_save Whether to save plots as a .tiff. Defaults to TRUE.
#'
#' @return Output. An SE for proportions (calculated using the binomial formula)
#'
#' @import magrittr
#' @import ggplot2
#'
#' @export
#'
#' @seealso \href{https://sean4andrew.github.io/safuncs/reference/Surv_Power.html}{Link} for web documentation.
#'
#' @examples
Surv_Power = function(simul_db = simul_db_ex,
                      global_test = "logrank", #selection(s) c("wald", "score", "LRT", "logrank")
                      model = NULL, #selection(s) from c("coxph_glm", "coxph_glmm", NULL). Defaults to NULL
                      pairwise_test = "logrank", #selection(s) c("EMM" or "logrank")
                      pairwise_corr = "none", #selection of c("tukey", "holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "none").
                      plot_out = TRUE,
                      plot_lines = FALSE,
                      xlab = "List Element #",
                      xnames = NULL,
                      plot_save = TRUE){

  #Track time elapsed
  time_start = Sys.time()

  #Convert NULL pairwise_corr into "none"
  if(is.null(pairwise_corr)){pairwise_corr <- "none"}

  #Standardize simul_db as dataframe
  if(!is.data.frame(simul_db)){simul_db = data.frame(simul_db$simul_surv_db)}

  #Add a value of 1 for column list_element_num in case no value is present in simul_db
  if(!"list_element_num" %in% colnames(simul_db)){simul_db$list_element_num <- 1}

  #Validation checks (stops)
  if(sum(!global_test %in% c("logrank", "wald", "score", "LRT")) > 0) {
    stop(paste("The", global_test[!global_test %in% c("logrank", "wald", "score", "LRT")][1], "global test method is not in the list supported by Surv_Power(). Select any amount from 'logrank', 'wald', 'score', and/or 'LRT'. For no global test to be done, select NULL. "))
  }

  if(sum(!model %in% c("coxph_glm", "coxph_glmm")) > 0) {
    stop(paste("The", model[!model %in% c("coxph_glm", "coxph_glmm")][1], "model is currently not in the list supported by Surv_Power(). Select any amount from 'coxph_glm' and/or 'coxph_glmm'. For no model to be fitted, select NULL."))
  }

  if(sum(!pairwise_test %in% c("logrank", "EMM")) > 0) {
    stop(paste("The", pairwise_test[!pairwise_test %in% c("logrank", "EMM")][1], "pairwise test method is not in the list supported by Surv_Power(). Select any amount from 'logrank' and/or 'EMM'. For no pairwise test to be done, select NULL."))
  }

  pairwise_corr_options = c("tukey", "holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "none")
  if(sum(!pairwise_corr %in% pairwise_corr_options) > 0) {
    stop(paste("The", pairwise_corr[!pairwise_corr %in% pairwise_corr_options][1], "pairwise correction method is not in the list supported by Surv_Power(). Select any amount from 'tukey', 'holm', 'hochberg', 'hommel', 'bonferroni', 'BH', 'BY', and/or 'none'."))
  }

  #Initialize objects to store values
  power_glob = data.frame()
  power_pair = data.frame()
  prog = 0

  #Subset data by list_element_num. Loop through each.
  for(ele_num in unique(simul_db$list_element_num)) {
    simul_db_temp0 = simul_db[simul_db$list_element_num == ele_num,] #filter for ele_num

    #Clear stored p_values for every ele_num
    p_pair = data.frame()
    p_glob = list()

    #Calculate a p-value for every loopnum
    for(simnum in unique(simul_db_temp0$n_sim)) {
      simul_db_temp = simul_db_temp0[simul_db_temp0$n_sim == simnum,] #filter for loopnum

      #Logrank tests
      #Global
      if("logrank" %in% global_test){
        p_glob[["N/Ap"]][["logrank"]][simnum] = survival::survdiff(survival::Surv(TTE, Status) ~ Trt.ID, simul_db_temp)$pvalue
      }

      #Pairwise
      for(pairwise_corr_id0 in pairwise_corr[pairwise_corr %in% c("holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr", "none")]){
        if("logrank" %in% pairwise_test) {
          pair_lr_res = survminer::pairwise_survdiff(survival::Surv(TTE, Status) ~ Trt.ID,
                                                     simul_db_temp, p.adjust.method = pairwise_corr_id0)
          temp_pair2 = data.frame(as.table(pair_lr_res$p.value))
          temp_pair2 = temp_pair2[-which(is.na(temp_pair2$Freq)),]

          p_pair = rbind(p_pair, data.frame(pair = interaction(temp_pair2$Var2, temp_pair2$Var1, sep = " - "),
                                            pvalues = temp_pair2$Freq,
                                            model = "N/Ap",
                                            pairwise_test = "logrank",
                                            corr = pairwise_corr_id0))
        }
      }

      #Model fits
      if("coxph_glm" %in% model){
        coxph_glm = survival::coxph(survival::Surv(TTE, Status) ~ Trt.ID, simul_db_temp)
        coxph_glm_sum = summary(coxph_glm)
      }
      if("coxph_glmm" %in% model){coxph_glmm <- coxme::coxme(survival::Surv(TTE, Status) ~ Trt.ID + (1|Tank.ID), simul_db_temp)}

      #Repeat for every model
      for(mod_id in model){ #for every model...

        #Repeat for every pairwise comparison correction setting
        for(pairwise_corr_id in pairwise_corr) { #for every pairwise comparison setting..
          if("EMM" %in% pairwise_test) {
            temp_pair = data.frame(emmeans::emmeans(mget(mod_id, envir = environment())[[1]],
                                                    pairwise ~ Trt.ID, adjust = pairwise_corr_id)$contrasts)

            p_pair = rbind(p_pair, data.frame(pair = temp_pair$contrast,
                                              pvalues = temp_pair$p.value,
                                              model = mod_id,
                                              pairwise_test = "EMM",
                                              corr = pairwise_corr_id))
          }
        }

        #Repeat for every global_test setting
        for(glob_id in global_test){
          if(glob_id == "wald"){p_glob[[mod_id]][[glob_id]][simnum] <- emmeans::joint_tests(mget(mod_id,
                                                                                                 envir = environment())[[1]])$p.value}
          if(glob_id == "score"){
            if(mod_id == "coxph_glm"){p_glob[[mod_id]][[glob_id]][simnum] <- coxph_glm_sum$waldtest["pvalue"]}
            if(mod_id == "coxph_glmm"){p_glob[[mod_id]][[glob_id]][simnum] <- NA} #Method not available/allowed
          }

          if(glob_id == "LRT"){
            if(mod_id == "coxph_glm"){p_glob[[mod_id]][[glob_id]][simnum] <- coxph_glm_sum$logtest["pvalue"]}
            if(mod_id == "coxph_glmm"){
              p_glob[[mod_id]][[glob_id]][simnum] =
                anova(coxph_glmm, coxme::coxme(survival::Surv(TTE, Status) ~ 1 + (1|Tank.ID), simul_db_temp))$`P(>|Chi|)`[2]
            }
          }
        }
      }

      #Print progress
      cat("\rCalculated p-values for", prog <- prog + 1, "of",
          max(simul_db$list_element_num) * max(simul_db_temp0$n_sim), "sample sets")
    } #Close loop for simnum

    #Create power tables from p-values for each ele_num
    #For global test pvalues
    if(length(p_glob) > 0){
      p_glob_unlist = stack(unlist(p_glob))
      p_glob_unlist$ind = gsub(pattern = "[0-9]", x = p_glob_unlist$ind, replacement = "")
      p_glob_db = data.frame(tidyr::separate(data = p_glob_unlist, col = "ind",
                                             into = c("model", "global_test"), sep = "\\."))
      power_glob_temp = data.frame(p_glob_db %>%
                                     dplyr::group_by(model, global_test) %>%
                                     dplyr::summarise(percent_signif = 100 * sum(values < 0.05)/length(values),
                                                      datasets_n = length(values), .groups = "drop"))
      power_glob_temp$percent_signif_se = sqrt(power_glob_temp$percent_signif *
                                                 (100-power_glob_temp$percent_signif) /
                                                 (power_glob_temp$datasets_n))
      power_glob_temp = power_glob_temp[, c("model", "global_test", "percent_signif", "percent_signif_se", "datasets_n")]
      power_glob_temp$element_num = ele_num
      power_glob = rbind(power_glob, power_glob_temp)
    }

    #For pairwise test pvalues
    if(length(p_pair) > 0){
      power_pair_temp = data.frame(p_pair %>%
                                     dplyr::group_by(pair, model, pairwise_test, corr) %>%
                                     dplyr::summarise(percent_signif = 100 * sum(pvalues < 0.05)/length(pvalues),
                                                      datasets_n = length(pvalues), .groups = "drop"))
      power_pair_temp$percent_signif_se = sqrt(power_pair_temp$percent_signif *
                                                 (100-power_pair_temp$percent_signif) /
                                                 (power_pair_temp$datasets_n))
      power_pair_temp = power_pair_temp[, c("pair", "model", "pairwise_test", "corr", "percent_signif",
                                            "percent_signif_se", "datasets_n")]
      power_pair_temp$element_num = ele_num
      power_pair = rbind(power_pair, power_pair_temp)
    }
  } #Close loop for ele_num

  #Outermost steps
  #Plot #1 (global test)
  if(length(p_glob) > 0){
    mod_col = c("N/Ap" = "#F8766D", "coxph_glm" = "#00BA38", "coxph_glmm" = "#00BFC4")
    power_glob$model = factor(power_glob$model, levels = c("N/Ap", "coxph_glm", "coxph_glmm"))
    power_glob$global_test = factor(power_glob$global_test, levels = c("logrank", "wald", "score", "LRT"))
    test_shapes = c(15:18)
    names(test_shapes) = c("logrank", "wald", "score", "LRT")

    glob_plot = ggplot(data = na.omit(power_glob), aes(x = as.numeric(element_num), y = percent_signif/100,
                                                       colour = model, group = interaction(model, global_test))) +
      geom_errorbar(aes(ymin = (percent_signif - percent_signif_se)/100,
                        ymax = (percent_signif + percent_signif_se)/100),
                    position = position_dodge(width = 0.12), width = 0.1) +
      geom_point(aes(shape = global_test), position = position_dodge(width = 0.12)) +
      scale_y_continuous(labels = scales::percent, breaks = seq(0, 1, 0.1), limits = c(0, 1),
                         name = "% of significant results (p<0.05)") +
      scale_x_continuous(breaks = seq(1, max(power_glob$element_num), 1),
                         name = ifelse(is.null(xlab), "List Element #", xlab),
                         labels = if(is.null(xnames)){waiver()}
                         else{stringr::str_wrap(xnames, width = round(24/max(power_pair$element_num)))}) +
      labs(color = "Model", shape = "Test", title = "Global Test of Significance") +
      theme(plot.title = element_text(hjust = 0)) +
      guides(linetype = "none",
             shape = guide_legend(order = 2),
             colour = guide_legend(order = 1)) +
      scale_color_manual(values = mod_col) +
      scale_shape_manual(values = test_shapes)

    if(plot_lines == TRUE) {glob_plot <- glob_plot + geom_line(aes(linetype = global_test), position = position_dodge(width = 0.12))}

  } else {glob_plot <- NULL}

  #Plot #2 (pairwise test)
  if(length(p_pair) > 0){
    power_pair$pair = gsub(" - ", " vs. ", power_pair$pair)
    u_pairs = length(unique(power_pair$pair))
    n_col = ceiling(u_pairs/2)
    test_and_corr_combos = rev(levels(interaction(c("logrank", "EMM"), pairwise_corr_options, sep = " & ")))[-1]
    power_pair$test_and_corr = interaction(power_pair$pairwise_test, power_pair$corr, sep = " & ")
    power_pair$test_and_corr = factor(power_pair$test_and_corr, levels = test_and_corr_combos)
    power_pair$model = factor(power_pair$model, levels = c("N/Ap", "coxph_glm", "coxph_glmm", "coxph_gee"))
    test_and_corr_shapes = c(3, rep(c(15:18, 4, 7, 25), each = 2))
    names(test_and_corr_shapes) = test_and_corr_combos

    pair_plot = ggplot(data = power_pair, aes(x = as.numeric(element_num), y = percent_signif/100, colour = model,
                                              group = interaction(model, test_and_corr))) +
      facet_wrap(~pair, ncol = n_col) +
      geom_errorbar(aes(ymin = (percent_signif - percent_signif_se)/100,
                        ymax = (percent_signif + percent_signif_se)/100),
                    position = position_dodge(width = 0.30), width = 0.1) +
      geom_point(aes(shape = test_and_corr), position = position_dodge(width = 0.30)) +
      scale_y_continuous(labels = scales::percent, breaks = seq(0, 1, 0.1), limits = c(0, 1),
                         name = "% of significant results (p<0.05)") +
      scale_x_continuous(breaks = seq(1, max(power_pair$element_num), 1),
                         name = ifelse(is.null(xlab), "List Element #", xlab),
                         labels = if(is.null(xnames)){waiver()}
                         else{stringr::str_wrap(xnames, width = round(48/(max(power_pair$element_num) * n_col)))}) +
      labs(color = "Model", shape = "Test & Correction", title = "Pairwise Test of Significance") +
      theme(plot.title = element_text(hjust = 0)) +
      guides(linetype = "none",
             shape = guide_legend(order = 2),
             colour = guide_legend(order = 1)) +
      scale_color_manual(values = mod_col) +
      scale_shape_manual(values = test_and_corr_shapes)


    if(plot_lines == TRUE) {pair_plot <- pair_plot + geom_line(aes(linetype = test_and_corr), position = position_dodge(width = 0.30))}
  } else {pair_plot <- NULL}

  #Return output
  output = list()
  if(!is.null(global_test)){
    output[["power_global_db"]] = power_glob
    if(plot_out == TRUE & length(power_glob) > 0) {
      output[["power_global_plot"]] = glob_plot
      if(plot_save == TRUE) {
        ggsave(paste("Power_Global_Test_", Sys.Date(), ".tiff", sep =""),
               dpi = 900, width = 7, height = 5.5, plot = glob_plot)
      }
    }
  }
  if(!is.null(pairwise_test)){
    output[["power_pairwise_db"]] = power_pair[, -which((colnames(power_pair) == "test_and_corr"))]
    if(plot_out == TRUE & length(pair_plot) > 0) {
      output[["power_pairwise_plot"]] = pair_plot
      if(plot_save == TRUE) {
        ggsave(paste("Power_Pairwise_Test_", Sys.Date(), ".tiff", sep =""),
               dpi = 900, width = 1.5 + (2.75 * ceiling(u_pairs / n_col)),
               height = 2.75 * n_col, plot = pair_plot)
      }
    }
  }

  #Validation checks (print notes)
  ##For global tests
  if("coxph_glmm" %in% model & "score" %in% global_test){
    print("NOTE: No off-the-shelf function for conducting a Likelihood Ratio Test on 'coxph_glmm' models in R. No power value is returned for the global test using LRT on 'coxph_glmm' model.")
  }

  ##For pairwise tests
  if("logrank" %in% pairwise_test & "tukey" %in% pairwise_corr) {
    print("NOTE: Tukey pairwise correction is not available for log-rank tests. No power value is returned for such a combination of test and correction.")
  }

  if(is.null(model)){
    if("EMM" %in% pairwise_test){
      print("NOTE: No pairwise comparison of type 'EMM' was done since no model was specified.")
    }
    if(sum(global_test %in% c("wald", "score", "LRT")) > 0){
      print(paste("NOTE: No global_test of type", global_test, "was done since no model was specified."))
    }
  }

  if(is.null(pairwise_test)){
    print("NOTE: No pairwise test was done since pairwise_test was set to NULL.")
  }
  if(is.null(global_test)){
    print("NOTE: No global test was done since global_test was set to NULL.")
  }

  #Print time elapsed
  print(paste("Time elapsed:", substr(hms::as_hms(Sys.time() - time_start), 1, 8), "(hh:mm:ss)"))
  return(output)
}

```

```{r}
power.fisher <- function(p1, p2, n, alpha, alternative)
{
# p1 = 0.5
# p2 = 0.3
# n = 30
# alpha = 0.05
# alternative = "two.sided"
#   
  pr1 <- dbinom(0:n, n, p1, log = T)
  pr2 <- dbinom(0:n, n, p2, log = T)
  y1 <- rep(0:n, each = n + 1)
  y2 <- rep(0:n, times = n + 1)
  y <- cbind(y1, n - y1, y2, n - y2)
  pr <- exp(rep(pr1, each = n + 1) + rep(pr2, times = n + 1))
  res <- 0
  for (i in 1:length(pr))
  {
    pval <- fisher.test(matrix(y[i, ], 2, 2), alternative = alternative)$p.value
    res <- res + (pval <= alpha) * pr[i]
  }

  return(res)
}
```

```{r}
Surv_Simul = function(haz_db,
                      fish_num_per_tank = 100,
                      tank_num_per_trt = 4,
                      treatments_hr = c(1, 1, 1, 1),
                      logHR_sd_intertank = 0,
                      sampling_specs = NULL,
                      exp_design = "between-tank",
                      n_sim = 1,
                      prog_show = TRUE,
                      plot_out = TRUE,
                      pop_out = TRUE,
                      theme = "ggplot2",
                      plot_save = TRUE) {
  #Track time elapsed
  time_start = Sys.time()

  #Making sure input data has correct (lower case) column names
  colnames(haz_db) = tolower(colnames(haz_db))

  #Validation check
  if(length(levels(factor(haz_db$tr.id))) > 1) {stop("Please use only one Trt.ID in the supplied hazard dataframe.")}

  #Add blank for last time point in haz_db, for convenience on later calculations
  haz_db = rbind(haz_db, data.frame(trt.id = haz_db$trt.id[1], hazard = last(cumsum(haz_db$hazard)) * .Machine$double.eps * 10, 
                                    time = round(last(haz_db$time))))

  #Initialize objects to store second output type (across list elements and loops)
  output2 = list(surv_plots = list(), surv_simul_db = data.frame(), surv_pop_db = data.frame())
  list_var_check = c()

  #Validation Check(s)
  if(plot_out == TRUE) {
    if(logHR_sd_intertank > 0) {
      print("NOTE: You specified a tank effect/contribution to variation, but the power shown in the plot is based of the logrank test. This test assumes no such tank effects. Adding tank-variation tends to decrease power of the logrank when the treatment effect is strong-modest (see Examples in Surv_Simul()'s documentation). Despite the decrease, power of the logrank will still be greater than that of other statistical tests which considers tank variation (assuming the experimental design is 'between-tank' because this matters). At the cost of having the greater power, logrank suffers from a greater false positive rate (> 5%). To calculate power of other tests that account for tank variation (hence keeping FPR at ~5%), use the coxph_glmm model option in the function Surv_Power() from package safuncs.")
    }
  }

  #Finding the input variable (var_name) that is a list and store info in var_list
  #First we stop the function if we find more than 1 list
  var_names = c("fish_num_per_tank", "tank_num_per_trt", "treatments_hr", "logHR_sd_intertank", "sampling_specs")
  for (var_name_check in var_names) {
    if(is.list(get(var_name_check, envir = environment())) & !is.data.frame(get(var_name_check, envir = environment()))){
      list_var_check = c(list_var_check, var_name_check)
    }
  }
  if(length(list_var_check) > 1) {stop("You specified more than 1 argument/parameter as a list. Currently, this is not allowed.")}

  for (var_name in var_names) {
    ifelse(is.list(get(var_name, envir = environment()))
           & !is.data.frame(get(var_name, envir = environment())),
           list_var <- get(var_name, envir = environment()),
           list_var <- "empty")
    if(length(list_var) > 1) {
      break
    }
  }

  #Track progress
  prog = 0

  #Change var_name based on list_var elements
  for (ele_num in 1:length(list_var)) {

    #if you have list elements, assign and print. If not just jump straight to old code
    if(length(list_var) > 1) { #if you have list elements, assign and print, otherwise just go to old code.
      assign(var_name, list_var[[ele_num]]) #assign
    }

    #Old code below. Will only run once if there is no list (i.e. length(list_var) = 1)

    #Initialize objects to store loop results
    surv_samps = data.frame() #for plotting purposes
    cens_db = data.frame() #for plotting purposes
    pvalues = c() #for plotting purposes
    Surv_simul_outDB = data.frame() #for dataoutput

    #Simulate survival dataframe
    for(loopnum in 1:n_sim) {

      CDF_Yval = c()
      Trt.ID = c()
      Tank.ID = c()
      Tank_num2 = 0
      iTT = 0

      if(exp_design == "between-tank") { #simulation procedure for between-tanks experimental design

        for(Treatment_Term in treatments_hr) {
          iTT = iTT + 1

          for(Tank_num in 1:ifelse(length(tank_num_per_trt) > 1, tank_num_per_trt[iTT], tank_num_per_trt)) {
            Tank_num2 = Tank_num2 + 1

            #Random sampling
            Tank_eff = rnorm(n = 1, mean = 0, sd = logHR_sd_intertank)

            U = runif(n = ifelse(length(fish_num_per_tank) > 1, fish_num_per_tank[iTT], fish_num_per_tank), min = 0, max = 1)

            CDF_Yval_temp = -log(U) * exp(-(log(Treatment_Term) + Tank_eff))
            CDF_Yval = append(CDF_Yval, CDF_Yval_temp)

            Trt.ID = c(Trt.ID, rep(c("Control", LETTERS[1:(length(treatments_hr) - 1)])[iTT], length(CDF_Yval_temp)))
            Tank.ID = c(Tank.ID, rep(Tank_num2, length(CDF_Yval_temp)))
          }
        }

      }
      if(exp_design == "within-tank") { #simulation procedure for within-tank experimental design. Similar but with flipped Tank-Trt loops.

        for(Tank_num in 1:tank_num_per_trt) { #only 1 tank num can be specified for the within-tank design.
          Tank_num2 = Tank_num2 + 1

          #Tank effect
          Tank_eff = rnorm(n = 1, mean = 0, sd = logHR_sd_intertank)

          iTT = 0
          for(Treatment_Term in treatments_hr) {
            iTT = iTT + 1

            #Simulate fish numbers per treatment for each tank. Write down in description that it must be per treatment per tank.
            #Can be as vector for treatment specific numbers or can be a single value if the same across treatments.
            U = runif(n = ifelse(length(fish_num_per_tank) > 1, fish_num_per_tank[iTT], fish_num_per_tank), min = 0, max = 1)

            CDF_Yval_temp = -log(U) * exp(-(log(Treatment_Term) + Tank_eff))
            CDF_Yval = append(CDF_Yval, CDF_Yval_temp)

            Trt.ID = c(Trt.ID, rep(c("Control", LETTERS[1:(length(treatments_hr) - 1)])[iTT], length(CDF_Yval_temp)))
            Tank.ID = c(Tank.ID, rep(Tank_num2, length(CDF_Yval_temp)))
          }
        }
      }

      #Get Time to Event
      TTE = approx(x = cumsum(haz_db$hazard), y = haz_db$time, xout = CDF_Yval, method = "linear")$y
      TTE = round(TTE, digits = 0)

      #Turn NA (from out of bound CDF_Yval) to the last follow up time
      TTE = ifelse(is.na(TTE), max(haz_db$time), TTE)

      #Label Status (1 - dead, or 0 - survived) given TTE, and create survival dataframe
      Surv_simul_DB = data.frame(TTE = TTE,
                                 Status = ifelse(TTE == max(haz_db$time), 0, 1),
                                 Trt.ID = Trt.ID,
                                 Tank.ID = Tank.ID,
                                 n_sim = loopnum)

      #Transform TTE and Status (to 0) in certain rows due to sampling
      if(!is.null(sampling_specs)) {

        if(!"Trt.ID" %in% colnames(sampling_specs)) {
          Trt_levels = unique(Surv_simul_DB$Trt.ID)
          sampling_specs = data.frame(TTE = rep(sampling_specs$TTE, each = length(Trt_levels)),
                                      Amount = rep(sampling_specs$Amount, each = length(Trt_levels)),
                                      Trt.ID = rep(unique(Trt_levels), times = nrow(sampling_specs)))
        }

        #Put in Tank.ID and replicate accordingly
        sampling_specs2 = merge(sampling_specs, unique(Surv_simul_DB[, 3:4]))

        #Run through every row of sampling_specs and sample accordingly
        for(samp_row in 1:nrow(sampling_specs2)) {

          rows_samp_space = which(Surv_simul_DB$Trt.ID == sampling_specs2$Trt.ID[samp_row] &
                                    Surv_simul_DB$Tank.ID == sampling_specs2$Tank.ID[samp_row] &
                                    Surv_simul_DB$TTE > sampling_specs2$TTE[samp_row])

          #Catch over sampling situation and print message
          if(length(rows_samp_space) < sampling_specs2$Amount[samp_row]) {
            print(paste(sep = "", "In simulation set-", loopnum, " Trt.ID-", sampling_specs2$Trt.ID[samp_row], ", Tank.ID-",
                        sampling_specs2$Tank.ID[samp_row],
                        ", you requested more samples than the fish alive! All remaining (living) fish sampled."))

            #Modify sampling amount
            sampling_specs2$Amount[samp_row] = length(rows_samp_space)
          }

          #Select rows that were sampled
          rows_sel = sample(x = rows_samp_space,
                            size = sampling_specs2$Amount[samp_row],
                            replace = FALSE)

          #Change Status and Time for sampled individuals
          Surv_simul_DB$TTE[rows_sel] = sampling_specs2$TTE[samp_row]
          Surv_simul_DB$Status[rows_sel] = 0
        }
      }

      #Get p-value for plots
      pvalues = append(pvalues, survival::survdiff(survival::Surv(TTE, Status) ~ Trt.ID, Surv_simul_DB)$pvalue)

      #Simulated survival data to be provided as output
      if(length(list_var) > 1){Surv_simul_DB$list_element_num <- ele_num}

      Surv_simul_outDB = rbind(Surv_simul_outDB, Surv_simul_DB)

      #Transform simulated survival data for plotting purposes
      surv_obj = survival::survfit(survival::Surv(TTE, Status) ~ Trt.ID, data = Surv_simul_DB)
      if(length(levels(as.factor(Surv_simul_DB$Trt.ID))) > 1) {
        attributes(surv_obj$strata)$names <- levels(as.factor(Surv_simul_DB$Trt.ID))
      } else {
        surv_obj$strata = length(surv_obj$surv)
        attributes(surv_obj$strata)$names <- levels(as.factor(Surv_simul_DB$Trt.ID))
      }

      surv_samps_temp = data.frame(Trt.ID = summary(surv_obj)$strata,
                                   surv_prob = summary(surv_obj)$surv,
                                   time = summary(surv_obj)$time,
                                   type = paste("Sample set (n = ", n_sim, ")", sep = ""),
                                   n_sim = loopnum,
                                   alpha = 1 - (0.0001 ^ (1/n_sim)))
      if(length(list_var) > 1){surv_samps_temp$list_element_num <- ele_num}

      surv_samps_ends = data.frame(surv_samps_temp %>%
                                     dplyr::group_by(Trt.ID) %>%
                                     dplyr::reframe(surv_prob = c(1, min(surv_prob)),
                                                    time = c(floor(min(haz_db$time)), ceiling(max(haz_db$time))),
                                                    n_sim = loopnum,
                                                    alpha = 1 - (0.0001 ^ (1/n_sim))))
      surv_samps_ends$type = paste("Sample set (n = ", n_sim, ")", sep = "")
      if(length(list_var) > 1){surv_samps_ends$list_element_num <- ele_num}

      surv_samps = rbind(surv_samps, surv_samps_temp, surv_samps_ends)

      if(!is.null(sampling_specs)){
        #Get survival probability at mid censoring
        cens_db_temp  = data.frame(Trt.ID = summary(surv_obj, time = sampling_specs$TTE)$strata,
                                   surv_prob = summary(surv_obj, time = sampling_specs$TTE)$surv,
                                   time = summary(surv_obj, time = sampling_specs$TTE)$time,
                                   n_sim = loopnum,
                                   type = as.factor(paste("Sample set (n = ", n_sim, ")", sep = "")))
        cens_db = rbind(cens_db, cens_db_temp)
      }

      #Print progress
      if(prog_show != FALSE) {cat("\rSimulated", prog <- prog + 1, "of", n_sim * length(list_var), "sample sets")}
    } #close loopnum

    #Get "population" survival dataset by exponentiating the negative cumulative hazard
    pop_haz_db = data.frame(approx(x = haz_db$time, y = haz_db$hazard, xout = seq(min(haz_db$time), max(haz_db$time), 0.1), method = "linear"))
    colnames(pop_haz_db) = c("time", "hazard")

    #For use with old surv_prob method (revived)
    surv_pop = data.frame(Trt.ID = as.factor(rep(c("Control", LETTERS[1:(length(treatments_hr) - 1)]), each = length(haz_db$hazard))),
                          #cumhaz_prob = as.vector(apply((haz_db$hazard) %*% t(treatments_hr), 2, cumsum)),
                          surv_prob = exp(-as.vector(apply(haz_db$hazard %*% t(treatments_hr), 2, cumsum))),
                          time = rep(haz_db$time, times = length(treatments_hr)),
                          type = "Population / truth",
                          n_sim = 1,
                          alpha = 1)
    if(length(list_var) > 1){surv_pop$list_element_num <- ele_num}

    #To the end of creating survival plots
    surv_comb = rbind(surv_samps, surv_pop)
    surv_comb$type = factor(surv_comb$type, levels = c(paste("Sample set (n = ", n_sim, ")", sep = ""), "Population / truth"))
    surv_comb$Trt.ID = factor(surv_comb$Trt.ID, levels = rep(c("Control", LETTERS[1:(length(treatments_hr) - 1)])))

    #Get end_sr for population plots and sample plots
    end_db = data.frame(surv_comb %>%
                          dplyr::group_by(type, Trt.ID, n_sim) %>%
                          dplyr::summarise(surv_prob = min(surv_prob), time = max(TTE), .groups = "drop") %>%
                          dplyr::group_by(type, Trt.ID) %>%
                          dplyr::summarise(surv_prob = mean(surv_prob), time = max(time), .groups = "drop"))

    #Get % significance (i.e. power) for plotting
    perc_sf = paste(round(100 * sum(pvalues < 0.05) / length(pvalues), digits = 0), "%", sep = "")

    #Ggplot
    surv_plots = ggplot(data = surv_comb, aes(x = time, y = surv_prob, colour = Trt.ID, group = interaction(n_sim, Trt.ID))) +
      facet_wrap(~ type) +
      geom_step(aes(alpha = alpha)) +
      scale_y_continuous(breaks = seq(0, 1, 0.1), limits = c(0, 1), labels = scales::percent) +
      scale_x_continuous(breaks = seq(0, max(surv_pop$time), max(round(max(surv_pop$time) / 12), 1))) +
      ylab("Survival Probability (%)") +
      xlab("Time to Event") +
      scale_alpha(range = c(min(surv_comb$alpha), 1)) +
      guides(alpha = "none") +
      coord_cartesian(clip = "off", xlim = c(min(haz_db$time), max(haz_db$time) - 0.5)) +
      theme(plot.margin = margin(5.5, 20, 5.5, 5.5))

    if(n_sim == 1) {
      surv_plots = surv_plots +
        geom_text(data = end_db, aes(x = time, y = surv_prob, label = round(surv_prob * 100, digits = 0)),
                  vjust = -0.3, hjust = 0.8, show.legend = FALSE, size = 3.3) +
        annotation_custom(grob = grid::textGrob(paste(c(paste("The sample has a", sep = ""),
                                                        paste("p-value = ", signif(pvalues, digits = 2), sep = ""),
                                                        "(global test of Trt.)"), collapse = "\n"),
                                                x = grid::unit(1.05, "npc"),
                                                y = grid::unit(0.08, "npc"),
                                                hjust = 0,
                                                gp = grid::gpar(fontsize = 9)))
    } else {
      surv_plots = surv_plots +
        geom_text(data = end_db[end_db$type == "Population / truth",],
                  aes(x = time, y = surv_prob, label = round(surv_prob * 100, digits = 0)),
                  vjust = -0.3, hjust = 0.8, show.legend = FALSE, size = 3.3) +
        annotation_custom(grob = grid::textGrob(paste(c(paste(perc_sf, " of the sample", sep = ""),
                                                        paste("sets (n) has p<0.05", sep = ""),
                                                        "(global test of Trt.)"), collapse = "\n"),
                                                x = grid::unit(1.03, "npc"),
                                                y = grid::unit(0.08, "npc"),
                                                hjust = 0,
                                                gp = grid::gpar(fontsize = 9)))
    }

    #Add censoring points
    if(!is.null(sampling_specs)) {
      merged_db = merge(sampling_specs2, Surv_simul_DB)
      merged_db = merged_db[merged_db$Status == 0, ]
      cens_db = cens_db[interaction(cens_db$Trt.ID, cens_db$time) %in% interaction(merged_db$Trt.ID, merged_db$TTE),]
      surv_plots = surv_plots +
        geom_point(data = cens_db, aes(x = time, y = surv_prob, colour = Trt.ID), shape = 3, size = 0.7, stroke = 1)
    }

    #Plot theme
    if(theme == "prism") {surv_plots = surv_plots + ggprism::theme_prism()}

    #Plot title
    if(length(list_var > 1)) {

      surv_plots = surv_plots + labs(title = paste("List Element", ele_num))
    }

    #Save plot
    if(plot_save == TRUE){
      ggsave(paste("Surv_Simul_Plot",
                   ifelse(length(list_var) == 1, "_", paste("_Element", ele_num, "_", sep ="")),
                   Sys.Date(), ".tiff", sep = ""), dpi = 900, width = 7, height = 4, plot = surv_plots)
    }

    #remove columns "alpha", "type", and "n_sim" from data output
    surv_pop = surv_pop[, -c(4:6)]
    colnames(surv_pop) = c("Trt.ID", "surv_prob", "TTE")

    #Return R output if list_var length = 1 (i.e. no list)
    if(length(list_var) == 1) {
      if(plot_out == FALSE & pop_out == FALSE) {
        #Print time elapsed
        print(paste("Time elapsed:", substr(hms::as_hms(Sys.time() - time_start), 1, 8), "(hh:mm:ss)"))
        return(surv_simul_db = Surv_simul_outDB)

      } else {

        output = list(surv_simul_db = Surv_simul_outDB)

        if(pop_out == TRUE) {output$surv_pop_db <- surv_pop}
        if(plot_out == TRUE) {output$surv_plots <- surv_plots}

        #Print time elapsed
        print(paste("Time elapsed:", substr(hms::as_hms(Sys.time() - time_start), 1, 8), "(hh:mm:ss)"))
        return(output)
      }
    }

    if(length(list_var) > 1) {

      #Store 2nd output if list_var length >1
      output2$surv_plots[[ele_num]] = surv_plots
      output2$surv_simul_db = rbind(output2$surv_simul_db, Surv_simul_outDB)
      output2$surv_pop_db = rbind(output2$surv_pop_db, surv_pop)
    }

    #Old code (non-lists stuff) ends here

  } #This closes the loop that deals with lists

  if(length(list_var) > 1){

    if(plot_out == FALSE) {
      output2$surv_plots = NULL
    }

    if(pop_out == FALSE) {
      output2$surv_pop_db = NULL
    }

    #Print time elapsed
    print(paste("Time elapsed:", substr(hms::as_hms(Sys.time() - time_start), 1, 8), "(hh:mm:ss)"))
    return(output2)
  }
}
```

```{r}
simul_db_ex = safuncs::Surv_Simul(haz_db = haz_db_ex,
          fish_num_per_tank = list(20, 60, 100),
          tank_num_per_trt = 3,
            treatments_hr = c(1, 0.5),
            n_sim = 30,
          pop_out = TRUE,
          plot_out = TRUE)
```



```{r}
simul_db_ex
```

Creating Surv_Power()
```{r}
simul_db = simul_db_ex
                      global_test = "logrank"
                      model = NULL
                      pairwise_test = "logrank"
                      pairwise_corr = "none"
                      prog_show = TRUE
                      plot_out = TRUE
                      plot_lines = FALSE
                      xlab = "List Element #"
                      xnames = NULL
                      plot_save = TRUE

  #Track time elapsed
  time_start = Sys.time()

  #Convert NULL pairwise_corr into "none"
  if(is.null(pairwise_corr)){pairwise_corr <- "none"}

  #Standardize simul_db as dataframe
  if(!is.data.frame(simul_db)){simul_db = data.frame(simul_db$simul_surv_db)}

  #Add a value of 1 for column list_element_num in case no value is present in simul_db
  if(!"list_element_num" %in% colnames(simul_db)){simul_db$list_element_num <- 1}

  #Validation checks (stops)
  if(sum(!global_test %in% c("logrank", "wald", "score", "LRT")) > 0) {
    stop(paste("The", global_test[!global_test %in% c("logrank", "wald", "score", "LRT")][1], "global test method is not in the list supported by Surv_Power(). Select any amount from 'logrank', 'wald', 'score', and/or 'LRT'. For no global test to be done, select NULL. "))
  }

  if(sum(!model %in% c("coxph_glm", "coxph_glmm")) > 0) {
    stop(paste("The", model[!model %in% c("coxph_glm", "coxph_glmm")][1], "model is currently not in the list supported by Surv_Power(). Select any amount from 'coxph_glm' and/or 'coxph_glmm'. For no model to be fitted, select NULL."))
  }

  if(sum(!pairwise_test %in% c("logrank", "EMM")) > 0) {
    stop(paste("The", pairwise_test[!pairwise_test %in% c("logrank", "EMM")][1], "pairwise test method is not in the list supported by Surv_Power(). Select any amount from 'logrank' and/or 'EMM'. For no pairwise test to be done, select NULL."))
  }

  pairwise_corr_options = c("tukey", "holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "none")
  if(sum(!pairwise_corr %in% pairwise_corr_options) > 0) {
    stop(paste("The", pairwise_corr[!pairwise_corr %in% pairwise_corr_options][1], "pairwise correction method is not in the list supported by Surv_Power(). Select any amount from 'tukey', 'holm', 'hochberg', 'hommel', 'bonferroni', 'BH', 'BY', and/or 'none'."))
  }

  #Initialize objects to store values
  power_glob = data.frame()
  power_pair = data.frame()
  prog = 0

  #Subset data by list_element_num. Loop through each.
  for(ele_num in unique(simul_db$list_element_num)) {
    simul_db_temp0 = simul_db[simul_db$list_element_num == ele_num,] #filter for ele_num

    #Clear stored p_values for every ele_num
    p_pair = data.frame()
    p_glob = list()

    #Calculate a p-value for every loopnum
    for(simnum in unique(simul_db_temp0$n_sim)) {
      simul_db_temp = simul_db_temp0[simul_db_temp0$n_sim == simnum,] #filter for loopnum

      #Logrank tests
      #Global
      if("logrank" %in% global_test){
        p_glob[["N/Ap"]][["logrank"]][simnum] = survival::survdiff(survival::Surv(TTE, Status) ~ Trt.ID, simul_db_temp)$pvalue
      }

      #Pairwise
      for(pairwise_corr_id0 in pairwise_corr[pairwise_corr %in% c("holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr", "none")]){
        if("logrank" %in% pairwise_test) {
          pair_lr_res = survminer::pairwise_survdiff(survival::Surv(TTE, Status) ~ Trt.ID,
                                                     simul_db_temp, p.adjust.method = pairwise_corr_id0)
          temp_pair2 = na.omit(data.frame(as.table(pair_lr_res$p.value)))

          p_pair = rbind(p_pair, data.frame(pair = interaction(temp_pair2$Var2, temp_pair2$Var1, sep = " - "),
                                            pvalues = temp_pair2$Freq,
                                            model = "N/Ap",
                                            pairwise_test = "logrank",
                                            corr = pairwise_corr_id0))
        }
      }

      #Model fits
      if("coxph_glm" %in% model){
        coxph_glm = survival::coxph(survival::Surv(TTE, Status) ~ Trt.ID, simul_db_temp)
        coxph_glm_sum = summary(coxph_glm)
      }
      if("coxph_glmm" %in% model){coxph_glmm <- coxme::coxme(survival::Surv(TTE, Status) ~ Trt.ID + (1|Tank.ID), simul_db_temp)}

      #Repeat for every model
      for(mod_id in model){ #for every model...

        #Repeat for every pairwise comparison correction setting
        for(pairwise_corr_id in pairwise_corr) { #for every pairwise comparison setting..
          if("EMM" %in% pairwise_test) {
            temp_pair = data.frame(emmeans::emmeans(mget(mod_id, envir = environment())[[1]],
                                                    pairwise ~ Trt.ID, adjust = pairwise_corr_id)$contrasts)

            p_pair = rbind(p_pair, data.frame(pair = temp_pair$contrast,
                                              pvalues = temp_pair$p.value,
                                              model = mod_id,
                                              pairwise_test = "EMM",
                                              corr = pairwise_corr_id))
          }
        }

        #Repeat for every global_test setting
        for(glob_id in global_test){
          if(glob_id == "wald"){p_glob[[mod_id]][[glob_id]][simnum] <- emmeans::joint_tests(mget(mod_id,
                                                                                                 envir = environment())[[1]])$p.value}
          if(glob_id == "score"){
            if(mod_id == "coxph_glm"){p_glob[[mod_id]][[glob_id]][simnum] <- coxph_glm_sum$waldtest["pvalue"]}
            if(mod_id == "coxph_glmm"){p_glob[[mod_id]][[glob_id]][simnum] <- NA} #Method not available/allowed
          }

          if(glob_id == "LRT"){
            if(mod_id == "coxph_glm"){p_glob[[mod_id]][[glob_id]][simnum] <- coxph_glm_sum$logtest["pvalue"]}
            if(mod_id == "coxph_glmm"){
              p_glob[[mod_id]][[glob_id]][simnum] =
                anova(coxph_glmm, coxme::coxme(survival::Surv(TTE, Status) ~ 1 + (1|Tank.ID), simul_db_temp))$`P(>|Chi|)`[2]
            }
          }
        }
      }

      #Print progress
      if(prog_show == TRUE) {cat("\rCalculated p-values for", prog <- prog + 1, "of",
                                  max(simul_db$list_element_num) * max(simul_db_temp0$n_sim), "sample sets")}
    } #Close loop for simnum

    #Create power tables from p-values for each ele_num
    #For global test pvalues
    if(length(p_glob) > 0){
      p_glob_unlist = stack(unlist(p_glob))
      p_glob_unlist$ind = gsub(pattern = "[0-9]", x = p_glob_unlist$ind, replacement = "")
      p_glob_db = data.frame(tidyr::separate(data = p_glob_unlist, col = "ind",
                                             into = c("model", "global_test"), sep = "\\."))
      power_glob_temp = data.frame(p_glob_db %>%
                                     dplyr::group_by(model, global_test) %>%
                                     dplyr::summarise(percent_signif = 100 * sum(values < 0.05)/length(values),
                                                      datasets_n = length(values), .groups = "drop"))
      power_glob_temp$percent_signif_se = sqrt(power_glob_temp$percent_signif *
                                                 (100-power_glob_temp$percent_signif) /
                                                 (power_glob_temp$datasets_n))
      power_glob_temp = power_glob_temp[, c("model", "global_test", "percent_signif", "percent_signif_se", "datasets_n")]
      power_glob_temp$element_num = ele_num
      power_glob = rbind(power_glob, power_glob_temp)
    }

    #For pairwise test pvalues
    if(length(p_pair) > 0){
      power_pair_temp = data.frame(p_pair %>%
                                     dplyr::group_by(pair, model, pairwise_test, corr) %>%
                                     dplyr::summarise(percent_signif = 100 * sum(pvalues < 0.05)/length(pvalues),
                                                      datasets_n = length(pvalues), .groups = "drop"))
      power_pair_temp$percent_signif_se = sqrt(power_pair_temp$percent_signif *
                                                 (100-power_pair_temp$percent_signif) /
                                                 (power_pair_temp$datasets_n))
      power_pair_temp = power_pair_temp[, c("pair", "model", "pairwise_test", "corr", "percent_signif",
                                            "percent_signif_se", "datasets_n")]
      power_pair_temp$element_num = ele_num
      power_pair = rbind(power_pair, power_pair_temp)
    }
  } #Close loop for ele_num

  #Outermost steps
  #Plot #1 (global test)
  if(length(p_glob) > 0){
    mod_col = c("N/Ap" = "#F8766D", "coxph_glm" = "#00BA38", "coxph_glmm" = "#00BFC4")
    power_glob$model = factor(power_glob$model, levels = c("N/Ap", "coxph_glm", "coxph_glmm"))
    power_glob$global_test = factor(power_glob$global_test, levels = c("logrank", "wald", "score", "LRT"))
    test_shapes = c(15:18)
    names(test_shapes) = c("logrank", "wald", "score", "LRT")

    glob_plot = ggplot(data = na.omit(power_glob), aes(x = as.numeric(element_num), y = percent_signif/100,
                                                       colour = model, group = interaction(model, global_test))) +
      geom_errorbar(aes(ymin = (percent_signif - percent_signif_se)/100,
                        ymax = (percent_signif + percent_signif_se)/100),
                    position = position_dodge(width = 0.12), width = 0.1) +
      geom_point(aes(shape = global_test), position = position_dodge(width = 0.12)) +
      scale_y_continuous(labels = scales::percent, breaks = seq(0, 1, 0.1), limits = c(0, 1),
                         name = "% of significant results (p<0.05)") +
      scale_x_continuous(breaks = seq(1, max(power_glob$element_num), 1),
                         name = ifelse(is.null(xlab), "List Element #", xlab),
                         labels = if(is.null(xnames)){waiver()}
                         else{stringr::str_wrap(xnames, width = round(24/max(power_pair$element_num)))}) +
      labs(color = "Model", shape = "Test", title = "Global Test of Significance") +
      theme(plot.title = element_text(hjust = 0)) +
      guides(linetype = "none",
             shape = guide_legend(order = 2),
             colour = guide_legend(order = 1)) +
      scale_color_manual(values = mod_col) +
      scale_shape_manual(values = test_shapes)

    if(plot_lines == TRUE) {glob_plot <- glob_plot + geom_line(aes(linetype = global_test), position = position_dodge(width = 0.12))}

  } else {glob_plot <- NULL}

  #Plot #2 (pairwise test)
  if(length(p_pair) > 0){
    power_pair$pair = gsub(" - ", " vs. ", power_pair$pair)
    u_pairs = length(unique(power_pair$pair))
    n_col = ceiling(u_pairs/2)
    test_and_corr_combos = rev(levels(interaction(c("logrank", "EMM"), pairwise_corr_options, sep = " & ")))[-1]
    power_pair$test_and_corr = interaction(power_pair$pairwise_test, power_pair$corr, sep = " & ")
    power_pair$test_and_corr = factor(power_pair$test_and_corr, levels = test_and_corr_combos)
    power_pair$model = factor(power_pair$model, levels = c("N/Ap", "coxph_glm", "coxph_glmm", "coxph_gee"))
    test_and_corr_shapes = c(3, rep(c(15:18, 4, 7, 25), each = 2))
    names(test_and_corr_shapes) = test_and_corr_combos

    pair_plot = ggplot(data = power_pair, aes(x = as.numeric(element_num), y = percent_signif/100, colour = model,
                                              group = interaction(model, test_and_corr))) +
      facet_wrap(~pair, ncol = n_col) +
      geom_errorbar(aes(ymin = (percent_signif - percent_signif_se)/100,
                        ymax = (percent_signif + percent_signif_se)/100),
                    position = position_dodge(width = 0.30), width = 0.1) +
      geom_point(aes(shape = test_and_corr), position = position_dodge(width = 0.30)) +
      scale_y_continuous(labels = scales::percent, breaks = seq(0, 1, 0.1), limits = c(0, 1),
                         name = "% of significant results (p<0.05)") +
      scale_x_continuous(breaks = seq(1, max(power_pair$element_num), 1),
                         name = ifelse(is.null(xlab), "List Element #", xlab),
                         labels = if(is.null(xnames)){waiver()}
                         else{stringr::str_wrap(xnames, width = round(48/(max(power_pair$element_num) * n_col)))}) +
      labs(color = "Model", shape = "Test & Correction", title = "Pairwise Test of Significance") +
      theme(plot.title = element_text(hjust = 0)) +
      guides(linetype = "none",
             shape = guide_legend(order = 2),
             colour = guide_legend(order = 1)) +
      scale_color_manual(values = mod_col) +
      scale_shape_manual(values = test_and_corr_shapes)


    if(plot_lines == TRUE) {pair_plot <- pair_plot + geom_line(aes(linetype = test_and_corr), position = position_dodge(width = 0.30))}
  } else {pair_plot <- NULL}

  #Return output
  output = list()
  if(!is.null(global_test)){
    output[["power_global_db"]] = power_glob
    if(plot_out == TRUE & length(power_glob) > 0) {
      output[["power_global_plot"]] = glob_plot
      if(plot_save == TRUE) {
        ggsave(paste("Power_Global_Test_", Sys.Date(), ".tiff", sep =""),
               dpi = 900, width = 7, height = 5.5, plot = glob_plot)
      }
    }
  }
  if(!is.null(pairwise_test)){
    output[["power_pairwise_db"]] = power_pair[, -which((colnames(power_pair) == "test_and_corr"))]
    if(plot_out == TRUE & length(pair_plot) > 0) {
      output[["power_pairwise_plot"]] = pair_plot
      if(plot_save == TRUE) {
        ggsave(paste("Power_Pairwise_Test_", Sys.Date(), ".tiff", sep =""),
               dpi = 900, width = 1.5 + (2.75 * ceiling(u_pairs / n_col)),
               height = 2.75 * n_col, plot = pair_plot)
      }
    }
  }

  #Validation checks (print notes)
  ##For global tests
  if("coxph_glmm" %in% model & "score" %in% global_test){
    print("NOTE: No off-the-shelf function for conducting a Likelihood Ratio Test on 'coxph_glmm' models in R. No power value is returned for the global test using LRT on 'coxph_glmm' model.")
  }

  ##For pairwise tests
  if("logrank" %in% pairwise_test & "tukey" %in% pairwise_corr) {
    print("NOTE: Tukey pairwise correction is not available for log-rank tests. No power value is returned for such a combination of test and correction.")
  }

  if(is.null(model)){
    if("EMM" %in% pairwise_test){
      print("NOTE: No pairwise comparison of type 'EMM' was done since no model was specified.")
    }
    if(sum(global_test %in% c("wald", "score", "LRT")) > 0){
      print(paste("NOTE: No global_test of type", global_test, "was done since no model was specified."))
    }
  }

  if(is.null(pairwise_test)){
    print("NOTE: No pairwise test was done since pairwise_test was set to NULL.")
  }
  if(is.null(global_test)){
    print("NOTE: No global test was done since global_test was set to NULL.")
  }

  #Print time elapsed
  print(paste("Time elapsed:", substr(hms::as_hms(Sys.time() - time_start), 1, 8), "(hh:mm:ss)"))
```


Surv_Power()
```{r}
Surv_Power(simul_db = simul_db_ex,
           model = c("coxph_glmm")           , #selection(s) from c("coxph_glm", "coxph_glmm", NULL). Defaults to NULL 
           global_test = c("logrank", "wald"), #selection(s) c("wald", "score", "LRT", "logrank")
           pairwise_test = c("logrank", "EMM"), #selection(s) c("EMM" or "logrank")
           pairwise_corr = c("none"), #selection of c("tukey", "holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "none").
           plot_out = TRUE,
           plot_lines = TRUE,
           xlab = NULL,
           xnames = NULL,
           plot_save = FALSE)
```


Surv_Gen()
```{r}
mort_db = mort_db_ex
starting_fish_count = 100
last_tte = 54
tank_without_mort = NULL
trt_without_mort = NULL
output = "prism"

  #Count the number of rows in mort_db, for each combination of treatment and tank ID
  DB_Mort_Gensum = data.frame(mort_db %>%
                                dplyr::group_by(Trt.ID, Tank.ID) %>%
                                dplyr::summarise(Num_dead = dplyr::n()))

  #Include tanks without morts in the count database
  if(!is.null(tank_without_mort) && !is.null(trt_without_mort)) {
    WM_DB = data.frame(Trt.ID = trt_without_mort,
                       Tank.ID = tank_without_mort,
                       Num_dead = 0)
    DB_Mort_Gensum = rbind(DB_Mort_Gensum, WM_DB)
  }

  #Use tank-specific starting fish count if information provided
  if(is.data.frame(starting_fish_count)) {
    DB_Mort_Gensum = base::merge(DB_Mort_Gensum, starting_fish_count, all.y = TRUE)
    DB_Mort_Gensum$Num_dead[is.na(DB_Mort_Gensum$Num_dead)] = 0
    DB_Mort_Gensum$Num_alive = DB_Mort_Gensum$starting_fish_count - DB_Mort_Gensum$Num_dead
    DB_Mort_Gensum = DB_Mort_Gensum[, -3]
  } else {DB_Mort_Gensum$Num_alive = starting_fish_count - DB_Mort_Gensum$Num_dead}

  #Generate rows of data representing survivors
  DB_Mort_Genalive = data.frame(lapply(DB_Mort_Gensum, rep, DB_Mort_Gensum$Num_alive))
  DB_Mort_Genalive$Status = 0
  DB_Mort_Genalive$TTE = last_tte
  DB_Mort_Gencomb = plyr::rbind.fill(mort_db, DB_Mort_Genalive[, -c(3:4)])
  
  #Create prism output
  if(output == "prism"){
    prism_db = data.frame(blank = rep("", nrow(DB_Mort_Gencomb)))
    
    for(col_nm in trt_levels) {
      temp_db = data.frame(ifelse(DB_Mort_Gencomb$Trt.ID == col_nm, DB_Mort_Gencomb$Status, ""))
      colnames(temp_db) = col_nm
      prism_db = cbind(prism_db, temp_db)
    }
    
    prism_db = cbind(data.frame(DB_Mort_Gencomb[, -which(colnames(DB_Mort_Gencomb) == "Status")]), 
                                prism_db[, -1])
    prism_db = data.frame(prism_db %>% arrange(Trt.ID, Tank.ID))[, -which(colnames(DB_Mort_Gencomb) == "Trt.ID")]
    
    write.csv(prism_db, "Surv_Gen Prism Survival Data.csv")
  }

  return(DB_Mort_Gencomb)
```

Label_Gen2?
```{r}
input_variables = list(Time = c("Baseline", "1wpv"),
                       Animal = c("Oysters", "Lobsters"),
                       Tissue = c("Meat", "Shell", "Water", "Head"))
n_col = 6
fill_by_row = TRUE


Label_Gen2 = function(list_input,
                      n_col = 6,
                      fil_by_row = TRUE,
                      save_name = NULL) {
  
  # Create combination data frame
  poss_grid = expand.grid(input_variables)
  
  # Sort output
  if(is.null(sort_by))
  combos = interaction(poss_grid, sep = ", ", lex.order = TRUE)
  ordered_combos = combos[order(poss_grid$Tissue)]
  extended_combos = c(paste(ordered_combos), 
                      rep("", times = ceiling(ceiling(length(ordered_combos)/n_col)/21) * 21 * n_col -
                            length(ordered_combos)))
  mat_combos = data.frame(matrix(extended_combos, ncol = n_col, byrow = fill_by_row))
  tab_combos = flextable::flextable(mat_combos, cwidth = 1.34, cheight = 1.7, use_labels = FALSE)
  tab_combos = bold(border_inner_v(border_inner_h(delete_part(
    fontsize(tab_combos, size = 9, part = "all"), part = "header"), 
    part = "all"), part = "all"), bold = TRUE, part = "all")
  
  # Save and print outputs
  print(paste("You have", length(combos), "total labels"))
  
  if(!is.null(save_name)){
    save_as_docx(tab_combos, values = list(tab_combos), path = paste(getwd(), "/Test2.docx", sep = ""),
                 pr_section = prop_section(page_size = page_size(orient = "portrait", height = 11, width = 8.5),
                                           page_margins = page_mar(bottom = 0, top = 0.25, right = 0.5, left = 0)))
    
  } else {
  
  }
  
  return(tab_combos)
}
  poss_grid = expand.grid(input_variables)
  combos = interaction(poss_grid, sep = ", ")
  ordered_combos = combos[order(poss_grid$Tissue)]
  extended_combos = c(paste(ordered_combos), 
                      rep("", times = ceiling(length(ordered_combos)/n_col) * n_col - length(ordered_combos)))
  mat_combos = data.frame(matrix(extended_combos, ncol = n_col, byrow = fill_by_row))
  
  z = regulartable(mat_combos)
  
View(mat_combos)
```

Label_Gen1
```{r}
input_variables = list(Time = c("Baseline", "1wpv"),
                       Animal = c("Oysters", "Lobsters"),
                       Tissue = c("Meat", "Shell", "Water", "Head"))
sort_by = c("Time", "Animal", "Tissue")
n_col = 6
fill_by_row = TRUE


Label_Gen = function(list_input,
                      sort_by = NULL,
                      n_col = 6,
                      fill_by_row = TRUE,
                      save_name = NULL) {
  
  # Create combination data frame
  poss_grid = expand.grid(input_variables)

  # Sort output
  if(is.null(sort_by)) {
    sort_by = names(input_variables)
  }
  rev_sb = rev(sort_by)
  for(i in rev_sb){
    poss_grid = poss_grid[order(poss_grid[, which(colnames(poss_grid) == i)]),]  
  }
  
  # Store ordered combinations
  ordered_combos = interaction(poss_grid, sep = ", ")
  extended_combos = c(paste(ordered_combos), 
                      rep("", times = ceiling(ceiling(length(ordered_combos)/n_col)/21) * 21 * n_col -
                            length(ordered_combos)))
  mat_combos = matrix(extended_combos, ncol = n_col, byrow = fill_by_row)
  colnames(mat_combos) = 1:n_col
  
  # Save and print outputs
  print(paste("You have", length(combos), "total labels"))
  
  if(is.null(save_name)){
    write.csv(x = mat_combos, file = paste("Label_Gen ", Sys.Date(), ".csv", sep = ""))
    print(paste("File saved as", paste("Label_Gen ", Sys.Date(), ".csv", sep = ""), "in", getwd()))
  } else {
    write.csv(x = mat_combos, file = paste(save_name, ".csv", sep = ""))
    print(paste("File saved as", paste(save_name, ".csv", sep = ""), "in", getwd()))
  }
}

# Summarize the input variables in a list
input_variables = list(Time = c("Baseline", "1wpv"),
                       Animal = c("Oysters", "Lobsters"),
                       Tissue = c("Meat", "Shell", "Water", "Head"))

# Run Label_Gen() using the input variables.
Label_Gen(list_input = input_variables,
          sort_by = c("Time", "Animal", "Tissue"),
          n_col = 6,
          fill_by_row = TRUE,
          save_name = NULL)
```
Methods to get surv_prob in Surv_Simul()
```{r}
  #methods to get surv_prob stored here below:
  #option 1 (old):
  #surv_prob = exp(-as.vector(apply(haz_db$hazard %*% t(treatments_hr), 2, cumsum)))

  #New method (deprecated)
  # surv_pop = data.frame()
  # for(pop_trt in levels(factor(surv_pop_old$Trt.ID))) {
  #   pop_trt_cumhaz = surv_pop_old$cumhaz_prob[surv_pop_old$Trt.ID == pop_trt]
  #   surv_prob_db = approx(x = haz_db$time, y = pop_trt_cumhaz, xout = seq(min(haz_db$time), max(haz_db$time), 0.1), method = "linear")
  #
  #   surv_pop_temp = data.frame(Trt.ID = pop_trt,
  #                              time = surv_prob_db$x,
  #                              surv_prob = exp(-surv_prob_db$y),
  #                              type = "Population / truth",
  #                              n_sim = 1,
  #                              alpha = 1)
  #   surv_pop = rbind(surv_pop, surv_pop_temp)
  # }
```


---
title: "Testing Grounds"
output: 
  rmdformats::readthedown:
    code_download: true
date: '`r format(Sys.time(), "%d %B, %Y")`'
---

# Heading 1

```{r}
remotes::install_github("sean4andrew/safuncs")
use_package() 
```


```{r}
Label_Gen(input_list = list(study_id = "ONDA01180",
                            timepoint = "100 dd",
                            animal = "salmon",
                            number = paste(1:20, "A", sep = ""),
                            tank = c("Tk.1", "Tk.2", "Tk.3", "Tk.4"),
                            tissue = c("Liver", "Spleen"),
                            solvent = "RNA"),
          sort_by = "tank")
```

```{r}
data(haz_db_ex)
safuncs::Surv_Simul(haz_db = haz_db_ex,
          fish_num_per_tank = list(30, 100),
          tank_num_per_trt = 3,
            treatments_hr = c(1, 0.6),
            n_sim = 30)$surv_plots
```

#### Ok finished testing with the list for between-tank designs. Now I need to do the same with within-tank designs. Also need to
#### resolve get() and getm() issues

Test
```{r}
Surv_Simul2 = function(haz_db = haz_db_ex,
                       fish_num_per_tank = 100, #can be a list
                       tank_num_per_trt = 3, #can be a list
                       treatments_hr = c(1, 0.5), #can be a list
                       logHR_sd_intertank = 0.5, #can be a list
                       sampling_specs = list(data.frame(TTE = c(20, 30),
                                 Amount = c(10, 10),
                                 Trt.ID = c("Control", "A")),
                      data.frame(TTE = c(40, 50),
                                 Amount = c(10, 10),
                                 Trt.ID = c("Control", "A"))), #can be a list
                      n_sim = 2,
                      plot_out = TRUE,
                      pop_out = TRUE,
                      exp_design = "within-tank",
                      theme = "ggplot2") {

  #Making sure input data has correct (lower case) column names
  colnames(haz_db) = tolower(colnames(haz_db))
  
  #Initialize objects to store second output type (across list elements and loops)
  output2 = list(surv_plots = list(), simul_surv_db = data.frame(), population_surv_db = data.frame())
  list_var_check = c()

  #Finding the input variable (var_name) that is a list and store info in var_list
  #First we stop the function if we find more than 1 list
  var_names = c("fish_num_per_tank", "tank_num_per_trt", "treatments_hr", "logHR_sd_intertank", "sampling_specs")
  for (var_name_check in var_names) {
    if(is.list(get(var_name_check, envir = environment())) & !is.data.frame(get(var_name_check, envir = environment()))){
      list_var_check = c(list_var_check, var_name_check)
    } 
  }
  if(length(list_var_check) > 1) {stop("You specified more than 1 argument/parameter as a list. Currently, this is not allowed.")}
  
  for (var_name in var_names) {
  ifelse(is.list(get(var_name, envir = environment())) 
         & !is.data.frame(get(var_name, envir = environment())), 
         list_var <- get(var_name, envir = environment()), 
         list_var <- "empty")
    if(length(list_var) > 1) {
      break
    }
  }
  
  #Change var_name based on list_var elements
  for (ele_num in 1:length(list_var)) {
      
    #if you have list elements, assign and print. If not just jump straight to old code
    if(length(list_var) > 1) { #if you have list elements, assign and print, otherwise just go to old code.
      assign(var_name, list_var[[ele_num]]) #assign
      print(paste("Simulating for ", #print
                  paste(var_name),
                  " list element #", 
                  ele_num,
                  sep = ""))
      } 
        
        #Old code below. Will only run once if there is no list (i.e. length(list_var) = 1)

  #Initialize objects to store loop results
  surv_samps = data.frame() #for plotting purposes
  cens_db = data.frame() #for plotting purposes
  pvalues = c() #for plotting purposes
  Surv_simul_outDB = data.frame() #for dataoutput

  #Simulate survival dataframe
  for(loopnum in 1:n_sim) {

    CDF_Yval = c()
    Trt.ID = c()
    Tank.ID = c()
    Tank_num2 = 0
    iTT = 0

    if(exp_design == "between-tank") { #simulation procedure for between-tanks experimental design

      for(Treatment_Term in treatments_hr) {
        iTT = iTT + 1
    
        for(Tank_num in 1:ifelse(length(tank_num_per_trt) > 1, tank_num_per_trt[iTT], tank_num_per_trt)) {
          Tank_num2 = Tank_num2 + 1
  
          #Random sampling
          Tank_eff = rnorm(n = 1, mean = 0, sd = logHR_sd_intertank)
  
          U = runif(n = ifelse(length(fish_num_per_tank) > 1, fish_num_per_tank[iTT], fish_num_per_tank), min = 0, max = 1)
  
          CDF_Yval_temp = -log(U) * exp(-(log(Treatment_Term) + Tank_eff))
          CDF_Yval = append(CDF_Yval, CDF_Yval_temp)
  
          Trt.ID = c(Trt.ID, rep(c("Control", LETTERS[1:(length(treatments_hr) - 1)])[iTT], length(CDF_Yval_temp)))
          Tank.ID = c(Tank.ID, rep(Tank_num2, length(CDF_Yval_temp)))
        }        
      }
      
    } 
    if(exp_design == "within-tank") { #simulation procedure for within-tank experimental design. Similar but with flipped Tank-Trt loops.
    
      for(Tank_num in 1:tank_num_per_trt) { #only 1 tank num can be specified for the within-tank design.
        Tank_num2 = Tank_num2 + 1
        
          #Tank effect
          Tank_eff = rnorm(n = 1, mean = 0, sd = logHR_sd_intertank)
        
        iTT = 0  
        for(Treatment_Term in treatments_hr) {
          iTT = iTT + 1
          
          #Simulate fish numbers per treatment for each tank. Write down in description that it must be per treatment per tank. 
          #Can be as vector for treatment specific numbers or can be a single value if the same across treatments.
          U = runif(n = ifelse(length(fish_num_per_tank) > 1, fish_num_per_tank[iTT], fish_num_per_tank), min = 0, max = 1)
          
          CDF_Yval_temp = -log(U) * exp(-(log(Treatment_Term) + Tank_eff))
          CDF_Yval = append(CDF_Yval, CDF_Yval_temp)
  
          Trt.ID = c(Trt.ID, rep(c("Control", LETTERS[1:(length(treatments_hr) - 1)])[iTT], length(CDF_Yval_temp)))
          Tank.ID = c(Tank.ID, rep(Tank_num2, length(CDF_Yval_temp)))
        }
      }
    }

    #Get Time to Event
    TTE = approx(x = cumsum(haz_db$hazard), y = haz_db$time, xout = CDF_Yval, method = "linear")$y
    TTE = round(TTE, digits = 0)

    #Turn NA (from out of bound CDF_Yval) to the last follow up time
    TTE = ifelse(is.na(TTE), max(haz_db$time), TTE)

    #Label Status (1 - dead, or 0 - survived) given TTE, and create survival dataframe
    Surv_simul_DB = data.frame(TTE = TTE,
                               Status = ifelse(TTE == max(haz_db$time), 0, 1),
                               Trt.ID = Trt.ID,
                               Tank.ID = Tank.ID,
                               n_sim = loopnum)

    #Transform TTE and Status (to 0) in certain rows due to sampling
    if(!is.null(sampling_specs)) {

      if(!"Trt.ID" %in% colnames(sampling_specs)) {
        Trt_levels = unique(Surv_simul_DB$Trt.ID)
        sampling_specs = data.frame(TTE = rep(sampling_specs$TTE, each = length(Trt_lvls)),
                                    Amount = rep(sampling_specs$Amount, each = length(Trt_lvls)),
                                    Trt.ID = rep(unique(Trt_levels, times = nrow(sampling_specs))))
      }
      
      #Put in Tank.ID and replicate accordingly
      sampling_specs2 = merge(sampling_specs, unique(Surv_simul_DB[, 3:4]))

      #Run through every row of sampling_specs and sample accordingly
      for(samp_row in 1:nrow(sampling_specs2)) {

        rows_samp_space = which(Surv_simul_DB$Trt.ID == sampling_specs2$Trt.ID[samp_row] &
                                  Surv_simul_DB$Tank.ID == sampling_specs2$Tank.ID[samp_row] &
                                  Surv_simul_DB$TTE > sampling_specs2$TTE[samp_row])

        #Catch over sampling situation and print message
        if(length(rows_samp_space) < sampling_specs2$Amount[samp_row]) {
          print(paste(sep = "", "In simulation set-", loopnum, " Trt.ID-", sampling_specs2$Trt.ID[samp_row], ", Tank.ID-",
                      sampling_specs2$Tank.ID[samp_row], 
                      ", you requested more samples than the fish alive! All remaining (living) fish sampled."))

          #Modify sampling amount
          sampling_specs2$Amount[samp_row] = length(rows_samp_space)
        }

        #Select rows that were sampled
        rows_sel = sample(x = rows_samp_space,
                          size = sampling_specs2$Amount[samp_row],
                          replace = FALSE)

        #Change Status and Time for sampled individuals
        Surv_simul_DB$TTE[rows_sel] = sampling_specs2$TTE[samp_row]
        Surv_simul_DB$Status[rows_sel] = 0
      }
    }

    #Get p-value for plots
    pvalues = append(pvalues, survival::survdiff(survival::Surv(TTE, Status) ~ Trt.ID, Surv_simul_DB)$pvalue)

    #Simulated survival data to be provided as output
    if(length(list_var) > 1){Surv_simul_DB$list_element_num <- ele_num}
    Surv_simul_outDB = rbind(Surv_simul_outDB, Surv_simul_DB)

    #Transform simulated survival data for plotting purposes
    surv_obj = survival::survfit(survival::Surv(TTE, Status) ~ Trt.ID, data = Surv_simul_DB)
    if(length(levels(as.factor(Surv_simul_DB$Trt.ID))) > 1) {
      attributes(surv_obj$strata)$names <- levels(as.factor(Surv_simul_DB$Trt.ID))
    } else {
      surv_obj$strata = length(surv_obj$surv)
      attributes(surv_obj$strata)$names <- levels(as.factor(Surv_simul_DB$Trt.ID))
    }

    surv_samps_temp = data.frame(Trt.ID = summary(surv_obj)$strata,
                                 surv_prob = summary(surv_obj)$surv,
                                 time = summary(surv_obj)$time,
                                 type = paste("Sample set (n = ", n_sim, ")", sep = ""),
                                 n_sim = loopnum,
                                 alpha = 1 - (0.0001 ^ (1/n_sim)))
    if(length(list_var) > 1){surv_samps_temp$list_element_num <- ele_num}

    surv_samps_ends = data.frame(surv_samps_temp %>%
                                   dplyr::group_by(Trt.ID) %>%
                                   dplyr::reframe(surv_prob = c(1, min(surv_prob)),
                                                  time = c(floor(min(haz_db$time)), ceiling(max(haz_db$time))),
                                                  n_sim = loopnum,
                                                  alpha = 1 - (0.0001 ^ (1/n_sim))))
    surv_samps_ends$type = paste("Sample set (n = ", n_sim, ")", sep = "")
    if(length(list_var) > 1){surv_samps_ends$list_element_num <- ele_num}

    surv_samps = rbind(surv_samps, surv_samps_temp, surv_samps_ends)

    if(!is.null(sampling_specs)){
      #Get survival probability at mid censoring
      cens_db_temp  = data.frame(Trt.ID = summary(surv_obj, time = sampling_specs$TTE)$strata,
                                 surv_prob = summary(surv_obj, time = sampling_specs$TTE)$surv,
                                 time = summary(surv_obj, time = sampling_specs$TTE)$time,
                                 n_sim = loopnum,
                                 type = as.factor(paste("Sample set (n = ", n_sim, ")", sep = "")))
      cens_db = rbind(cens_db, cens_db_temp)
    }
  }

  #Get "population" survival dataset by exponentiating the negative cumulative hazard
  pop_haz_db = data.frame(approx(x = haz_db$time, y = haz_db$hazard, xout = seq(min(haz_db$time), max(haz_db$time), 0.1), method = "linear"))
  colnames(pop_haz_db) = c("time", "hazard")

  #For use with old surv_prob method (revived)
  surv_pop = data.frame(Trt.ID = as.factor(rep(c("Control", LETTERS[1:(length(treatments_hr) - 1)]), each = length(haz_db$hazard))),
                        #cumhaz_prob = as.vector(apply((haz_db$hazard) %*% t(treatments_hr), 2, cumsum)),
                        surv_prob = exp(-as.vector(apply(haz_db$hazard %*% t(treatments_hr), 2, cumsum))),
                        time = rep(haz_db$time, times = length(treatments_hr)),
                        type = "Population / truth",
                        n_sim = 1,
                        alpha = 1)
  if(length(list_var) > 1){surv_pop$list_element_num <- ele_num}

  #To the end of creating survival plots
  surv_comb = rbind(surv_samps, surv_pop)
  surv_comb$type = factor(surv_comb$type, levels = c(paste("Sample set (n = ", n_sim, ")", sep = ""), "Population / truth"))
  surv_comb$Trt.ID = factor(surv_comb$Trt.ID, levels = rep(c("Control", LETTERS[1:(length(treatments_hr) - 1)])))

  #Get end_sr for population plots and sample plots
  end_db = data.frame(surv_comb %>%
                        dplyr::group_by(type, Trt.ID, n_sim) %>%
                        dplyr::summarise(surv_prob = min(surv_prob), time = max(TTE), .groups = "drop") %>%
                        dplyr::group_by(type, Trt.ID) %>%
                        dplyr::summarise(surv_prob = mean(surv_prob), time = max(time), .groups = "drop"))

  #Get % significance (i.e. power) for plotting
  perc_sf = paste(round(100 * sum(pvalues < 0.05) / length(pvalues), digits = 0), "%", sep = "")

  #Ggplot
  surv_plots = ggplot(data = surv_comb, aes(x = time, y = surv_prob, colour = Trt.ID, group = interaction(n_sim, Trt.ID))) +
    facet_wrap(~ type) +
    geom_step(aes(alpha = alpha)) +
    scale_y_continuous(breaks = seq(0, 1, 0.1), limits = c(0, 1), labels = scales::percent) +
    scale_x_continuous(breaks = seq(0, max(surv_pop$time), max(round(max(surv_pop$time) / 12), 1))) +
    ylab("Survival Probability (%)") +
    xlab("Time to Event") +
    scale_alpha(range = c(min(surv_comb$alpha), 1)) +
    guides(alpha = "none") +
    coord_cartesian(clip = "off") +
    theme(plot.margin = margin(5.5, 20, 5.5, 5.5))

  if(n_sim == 1) {
    surv_plots = surv_plots +
      geom_text(data = end_db, aes(x = time, y = surv_prob, label = round(surv_prob * 100, digits = 0)),
                vjust = -0.3, hjust = 0.8, show.legend = FALSE, size = 3.3) +
      annotation_custom(grob = grid::textGrob(paste(c(paste("The sample has a", sep = ""),
                                                      paste("p-value = ", signif(pvalues, digits = 2), sep = ""),
                                                      "(global test of Trt.)"), collapse = "\n"),
                                              x = grid::unit(1.05, "npc"),
                                              y = grid::unit(0.08, "npc"),
                                              hjust = 0,
                                              gp = grid::gpar(fontsize = 9)))
  } else {
    surv_plots = surv_plots +
      geom_text(data = end_db[end_db$type == "Population / truth",],
                aes(x = time, y = surv_prob, label = round(surv_prob * 100, digits = 0)),
                vjust = -0.3, hjust = 0.8, show.legend = FALSE, size = 3.3) +
      annotation_custom(grob = grid::textGrob(paste(c(paste(perc_sf, " of the sample", sep = ""),
                                                      paste("sets (n) has p<0.05", sep = ""),
                                                      "(global test of Trt.)"), collapse = "\n"),
                                              x = grid::unit(1.03, "npc"),
                                              y = grid::unit(0.08, "npc"),
                                              hjust = 0,
                                              gp = grid::gpar(fontsize = 9)))
  }

  #Add censoring points
  if(!is.null(sampling_specs)) {
    merged_db = merge(sampling_specs2, Surv_simul_DB)
    merged_db = merged_db[merged_db$Status == 0, ]
    cens_db = cens_db[interaction(cens_db$Trt.ID, cens_db$time) %in% interaction(merged_db$Trt.ID, merged_db$TTE),]
    surv_plots = surv_plots +
      geom_point(data = cens_db, aes(x = time, y = surv_prob, colour = Trt.ID), shape = 3, size = 0.7, stroke = 1)
  }

  #Plot theme
  if(theme == "prism") {surv_plots = surv_plots + ggprism::theme_prism()}

  #Save plot
  ggsave(paste("Simul_Surv_Plot", 
               ifelse(length(list_var) == 1, "_", paste("_Element", ele_num, "_", sep ="")),
               Sys.Date(), ".tiff", sep = ""), dpi = 900, width = 7, height = 4, plot = surv_plots)
  surv_pop = surv_pop[, -6] #remove "alpha" column from data output
  
  #Return R output if list_var length = 1 (i.e. no list)
  if(length(list_var) == 1) {
    if(plot_out == FALSE & pop_out == FALSE) {
      return(simul_surv_db = Surv_simul_outDB)
  
    } else {
  
      output = list(simul_surv_db = Surv_simul_outDB)
      
      if(plot_out == TRUE) {
        output$surv_plots <- surv_plots
        if(logHR_sd_intertank > 0 & exp_design == "between-tank") {
          print("NOTE: You specified a tank effect/contribution to variation, but the power shown in the figure is based of the log-rank test which assumes no such effects. Additionally, you specified a between-tank experimental design. As a result, the power of the log-rank test can increase/decrease. Meanwhile its false positive rate (FPR) will increase. Importantly, FPR could rise far above 5% which is implied when researchers preset their test's alpha to 0.05 (hence the claim of 5% FPR is untrue). To calculate power of more appropriate statistical test(s) see safuncs::Surv_Power().")
        }
        if(logHR_sd_intertank > 0 & exp_design == "within-tank") {
          print("NOTE: You specified a tank effect/contribution to variation, but the power shown in the figure is based of the log-rank test which assumes no such effects. Additionally, you specified a within-tank experimental design. As a result, the power of the log-rank test could be less than what is deserved given the data structure in a within-tank design. To calculate power of more appropriate statistical test(s) see safuncs::Surv_Power().")
        }
      }
      
      if(pop_out == TRUE) {output$population_surv_db <- surv_pop}
      return(output)
    }
  } 
  
  if(length(list_var) > 1) {

    #Store 2nd output if list_var length >1
    output2$surv_plots[[ele_num]] = surv_plots
    output2$simul_surv_db = rbind(output2$simul_surv_db, Surv_simul_outDB)
    output2$population_surv_db = rbind(output2$population_surv_db, surv_pop)   
  }

  #Old code (non-lists stuff) ends here
  
  } #This closes the loop that deals with lists

  if(length(list_var) > 1){
    
    if(plot_out == FALSE) {
      output2$surv_plots = NULL
    } else {        
        if(logHR_sd_intertank > 0 & exp_design == "within-tank") {
          print("NOTE: You specified a tank effect/contribution to variation, but the power shown in the figure is based of the log-rank test which assumes no such effects. Additionally, you specified a within-tank experimental design. As a result, the power of the log-rank test could be less than what is deserved given the data structure in a within-tank design. To calculate power of more appropriate statistical test(s) see safuncs::Surv_Power().")
        }
        if(logHR_sd_intertank > 0 & exp_design == "between-tank") {
          print("NOTE: You specified a tank effect/contribution to variation, but the power shown in the figure is based of the log-rank test which assumes no such effects. Additionally, you specified a between-tank experimental design. As a result, the power of the log-rank test can increase/decrease. Meanwhile its false positive rate (FPR) will increase. Importantly, FPR could rise far above 5% which is implied when researchers preset their test's alpha to 0.05 (hence the claim of 5% FPR is untrue). To calculate power of more appropriate statistical test(s) see safuncs::Surv_Power().")
        }
      }
    
    if(pop_out == FALSE) {
      output2$population_surv_db = NULL
    }
    
    return(output2)
  }
}
```


```{r}
#output = Surv_Simul2()

safuncs::Surv_Simul(haz_db = haz_db_ex,
            fish_num_per_tank = list(50, 200),
            tank_num_per_trt = 3,
            treatments_hr = c(1, 0.6),
            n_sim = 20)$surv_plots
```

```{r, fig.width = 6.3, fig.height = 4}
#print(output2)
print(output2$surv_plots)
```

Creating Surv_Power()
```{r}
#Produces plots under list_mode. 
Surv_Power = function(simul_db,
                      test_or_model, #selection(s) from c("log-rank", "coxph_glm", "coxph_gee", "coxph_glmm"), 
                      model_global_test = "wald", #selection(s) c("wald", "score", "LRT") #argument ignored when test_or_model = "log-rank"
                      pairwise_test_corr = "none"){ #selection(s) of c("tukey", "dunnet", "bonferroni", "BH", "BY", "none") #
                      
  
}

simul_db = simul_db_ex
test_or_model = "log-rank"
pairwise_test_corr = c("")


```


Surv_Gen()
```{r}
mort_db = mort_db_ex
starting_fish_count = 100
last_tte = 54
tank_without_mort = NULL
trt_without_mort = NULL
output = "prism"

  #Count the number of rows in mort_db, for each combination of treatment and tank ID
  DB_Mort_Gensum = data.frame(mort_db %>%
                                dplyr::group_by(Trt.ID, Tank.ID) %>%
                                dplyr::summarise(Num_dead = dplyr::n()))

  #Include tanks without morts in the count database
  if(!is.null(tank_without_mort) && !is.null(trt_without_mort)) {
    WM_DB = data.frame(Trt.ID = trt_without_mort,
                       Tank.ID = tank_without_mort,
                       Num_dead = 0)
    DB_Mort_Gensum = rbind(DB_Mort_Gensum, WM_DB)
  }

  #Use tank-specific starting fish count if information provided
  if(is.data.frame(starting_fish_count)) {
    DB_Mort_Gensum = base::merge(DB_Mort_Gensum, starting_fish_count, all.y = TRUE)
    DB_Mort_Gensum$Num_dead[is.na(DB_Mort_Gensum$Num_dead)] = 0
    DB_Mort_Gensum$Num_alive = DB_Mort_Gensum$starting_fish_count - DB_Mort_Gensum$Num_dead
    DB_Mort_Gensum = DB_Mort_Gensum[, -3]
  } else {DB_Mort_Gensum$Num_alive = starting_fish_count - DB_Mort_Gensum$Num_dead}

  #Generate rows of data representing survivors
  DB_Mort_Genalive = data.frame(lapply(DB_Mort_Gensum, rep, DB_Mort_Gensum$Num_alive))
  DB_Mort_Genalive$Status = 0
  DB_Mort_Genalive$TTE = last_tte
  DB_Mort_Gencomb = plyr::rbind.fill(mort_db, DB_Mort_Genalive[, -c(3:4)])
  
  #Create prism output
  if(output == "prism"){
    prism_db = data.frame(blank = rep("", nrow(DB_Mort_Gencomb)))
    
    for(col_nm in trt_levels) {
      temp_db = data.frame(ifelse(DB_Mort_Gencomb$Trt.ID == col_nm, DB_Mort_Gencomb$Status, ""))
      colnames(temp_db) = col_nm
      prism_db = cbind(prism_db, temp_db)
    }
    
    prism_db = cbind(data.frame(DB_Mort_Gencomb[, -which(colnames(DB_Mort_Gencomb) == "Status")]), 
                                prism_db[, -1])
    prism_db = data.frame(prism_db %>% arrange(Trt.ID, Tank.ID))[, -which(colnames(DB_Mort_Gencomb) == "Trt.ID")]
    
    write.csv(prism_db, "Surv_Gen Prism Survival Data.csv")
  }

  return(DB_Mort_Gencomb)
```

Label_Gen2?
```{r}
input_variables = list(Time = c("Baseline", "1wpv"),
                       Animal = c("Oysters", "Lobsters"),
                       Tissue = c("Meat", "Shell", "Water", "Head"))
n_col = 6
fill_by_row = TRUE


Label_Gen2 = function(list_input,
                      n_col = 6,
                      fil_by_row = TRUE,
                      save_name = NULL) {
  
  # Create combination data frame
  poss_grid = expand.grid(input_variables)
  
  # Sort output
  if(is.null(sort_by))
  combos = interaction(poss_grid, sep = ", ", lex.order = TRUE)
  ordered_combos = combos[order(poss_grid$Tissue)]
  extended_combos = c(paste(ordered_combos), 
                      rep("", times = ceiling(ceiling(length(ordered_combos)/n_col)/21) * 21 * n_col -
                            length(ordered_combos)))
  mat_combos = data.frame(matrix(extended_combos, ncol = n_col, byrow = fill_by_row))
  tab_combos = flextable::flextable(mat_combos, cwidth = 1.34, cheight = 1.7, use_labels = FALSE)
  tab_combos = bold(border_inner_v(border_inner_h(delete_part(
    fontsize(tab_combos, size = 9, part = "all"), part = "header"), 
    part = "all"), part = "all"), bold = TRUE, part = "all")
  
  # Save and print outputs
  print(paste("You have", length(combos), "total labels"))
  
  if(!is.null(save_name)){
    save_as_docx(tab_combos, values = list(tab_combos), path = paste(getwd(), "/Test2.docx", sep = ""),
                 pr_section = prop_section(page_size = page_size(orient = "portrait", height = 11, width = 8.5),
                                           page_margins = page_mar(bottom = 0, top = 0.25, right = 0.5, left = 0)))
    
  } else {
  
  }
  
  return(tab_combos)
}
  poss_grid = expand.grid(input_variables)
  combos = interaction(poss_grid, sep = ", ")
  ordered_combos = combos[order(poss_grid$Tissue)]
  extended_combos = c(paste(ordered_combos), 
                      rep("", times = ceiling(length(ordered_combos)/n_col) * n_col - length(ordered_combos)))
  mat_combos = data.frame(matrix(extended_combos, ncol = n_col, byrow = fill_by_row))
  
  z = regulartable(mat_combos)
  
View(mat_combos)
```

Label_Gen1
```{r}
input_variables = list(Time = c("Baseline", "1wpv"),
                       Animal = c("Oysters", "Lobsters"),
                       Tissue = c("Meat", "Shell", "Water", "Head"))
sort_by = c("Time", "Animal", "Tissue")
n_col = 6
fill_by_row = TRUE


Label_Gen = function(list_input,
                      sort_by = NULL,
                      n_col = 6,
                      fill_by_row = TRUE,
                      save_name = NULL) {
  
  # Create combination data frame
  poss_grid = expand.grid(input_variables)

  # Sort output
  if(is.null(sort_by)) {
    sort_by = names(input_variables)
  }
  rev_sb = rev(sort_by)
  for(i in rev_sb){
    poss_grid = poss_grid[order(poss_grid[, which(colnames(poss_grid) == i)]),]  
  }
  
  # Store ordered combinations
  ordered_combos = interaction(poss_grid, sep = ", ")
  extended_combos = c(paste(ordered_combos), 
                      rep("", times = ceiling(ceiling(length(ordered_combos)/n_col)/21) * 21 * n_col -
                            length(ordered_combos)))
  mat_combos = matrix(extended_combos, ncol = n_col, byrow = fill_by_row)
  colnames(mat_combos) = 1:n_col
  
  # Save and print outputs
  print(paste("You have", length(combos), "total labels"))
  
  if(is.null(save_name)){
    write.csv(x = mat_combos, file = paste("Label_Gen ", Sys.Date(), ".csv", sep = ""))
    print(paste("File saved as", paste("Label_Gen ", Sys.Date(), ".csv", sep = ""), "in", getwd()))
  } else {
    write.csv(x = mat_combos, file = paste(save_name, ".csv", sep = ""))
    print(paste("File saved as", paste(save_name, ".csv", sep = ""), "in", getwd()))
  }
}

# Summarize the input variables in a list
input_variables = list(Time = c("Baseline", "1wpv"),
                       Animal = c("Oysters", "Lobsters"),
                       Tissue = c("Meat", "Shell", "Water", "Head"))

# Run Label_Gen() using the input variables.
Label_Gen(list_input = input_variables,
          sort_by = c("Time", "Animal", "Tissue"),
          n_col = 6,
          fill_by_row = TRUE,
          save_name = NULL)
```
Methods to get surv_prob in Surv_Simul()
```{r}
  #methods to get surv_prob stored here below:
  #option 1 (old):
  #surv_prob = exp(-as.vector(apply(haz_db$hazard %*% t(treatments_hr), 2, cumsum)))

  #New method (deprecated)
  # surv_pop = data.frame()
  # for(pop_trt in levels(factor(surv_pop_old$Trt.ID))) {
  #   pop_trt_cumhaz = surv_pop_old$cumhaz_prob[surv_pop_old$Trt.ID == pop_trt]
  #   surv_prob_db = approx(x = haz_db$time, y = pop_trt_cumhaz, xout = seq(min(haz_db$time), max(haz_db$time), 0.1), method = "linear")
  #
  #   surv_pop_temp = data.frame(Trt.ID = pop_trt,
  #                              time = surv_prob_db$x,
  #                              surv_prob = exp(-surv_prob_db$y),
  #                              type = "Population / truth",
  #                              n_sim = 1,
  #                              alpha = 1)
  #   surv_pop = rbind(surv_pop, surv_pop_temp)
  # }
```

